// Generated by TFLite Support.
package de.fff.ccgt.classify;

import android.content.Context;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.tensorflow.lite.DataType;
import org.tensorflow.lite.support.common.TensorProcessor;
import org.tensorflow.lite.support.common.ops.CastOp;
import org.tensorflow.lite.support.common.ops.DequantizeOp;
import org.tensorflow.lite.support.common.ops.NormalizeOp;
import org.tensorflow.lite.support.common.ops.QuantizeOp;
import org.tensorflow.lite.support.metadata.MetadataExtractor;
import org.tensorflow.lite.support.metadata.schema.NormalizationOptions;
import org.tensorflow.lite.support.model.Model;
import org.tensorflow.lite.support.model.Model.Device;
import org.tensorflow.lite.support.tensorbuffer.TensorBuffer;

/** Wrapper class of model SPICE (Version: V2) */
public class SpiceTFLiteModel {
    private final Metadata metadata;
    private final Model model;
    private static final String MODEL_NAME = "lite-model_spice_1.tflite";
    @Nullable private TensorProcessor inputAudioSamplesPreprocessor;
    @Nullable private TensorProcessor pitchesPostprocessor;
    @Nullable private TensorProcessor uncertaintiesPostprocessor;

    /** Input wrapper of {@link SpiceTFLiteModel} */
    public class Inputs {
        private TensorBuffer inputAudioSamples;

        public Inputs() {
            Metadata metadata = SpiceTFLiteModel.this.metadata;
            inputAudioSamples = TensorBuffer.createFixedSize(metadata.getInputAudioSamplesShape(), metadata.getInputAudioSamplesType());
        }

        public void loadInputAudioSamples(TensorBuffer tensorBuffer) {
            inputAudioSamples = preprocessInputAudioSamples(tensorBuffer);
        }

        private TensorBuffer preprocessInputAudioSamples(TensorBuffer tensorBuffer) {
            if (inputAudioSamplesPreprocessor == null) {
                return tensorBuffer;
            }
            return inputAudioSamplesPreprocessor.process(tensorBuffer);
        }

        Object[] getBuffer() {
            return new Object[] {inputAudioSamples.getBuffer()};
        }
    }

    /** Output wrapper of {@link SpiceTFLiteModel} */
    public class Outputs {
        private final TensorBuffer pitches;
        private final TensorBuffer uncertainties;

        public Outputs() {
            Metadata metadata = SpiceTFLiteModel.this.metadata;
            pitches = TensorBuffer.createFixedSize(metadata.getPitchesShape(), metadata.getPitchesType());
            uncertainties = TensorBuffer.createFixedSize(metadata.getUncertaintiesShape(), metadata.getUncertaintiesType());
        }

        public TensorBuffer getPitches() {
            return postprocessPitches(pitches);
        }

        private TensorBuffer postprocessPitches(TensorBuffer tensorBuffer) {
            if (pitchesPostprocessor == null) {
                return tensorBuffer;
            }
            return pitchesPostprocessor.process(tensorBuffer);
        }

        public TensorBuffer getUncertainties() {
            return postprocessUncertainties(uncertainties);
        }

        private TensorBuffer postprocessUncertainties(TensorBuffer tensorBuffer) {
            if (uncertaintiesPostprocessor == null) {
                return tensorBuffer;
            }
            return uncertaintiesPostprocessor.process(tensorBuffer);
        }

        Map<Integer, Object> getBuffer() {
            Map<Integer, Object> outputs = new HashMap<>();
            outputs.put(0, pitches.getBuffer());
            outputs.put(1, uncertainties.getBuffer());
            return outputs;
        }
    }

    /** Metadata accessors of {@link SpiceTFLiteModel} */
    public static class Metadata {
        private final int[] inputAudioSamplesShape;
        private final DataType inputAudioSamplesDataType;
        private final MetadataExtractor.QuantizationParams inputAudioSamplesQuantizationParams;
        private final float[] inputAudioSamplesMean;
        private final float[] inputAudioSamplesStddev;
        private final int[] pitchesShape;
        private final DataType pitchesDataType;
        private final MetadataExtractor.QuantizationParams pitchesQuantizationParams;
        private final int[] uncertaintiesShape;
        private final DataType uncertaintiesDataType;
        private final MetadataExtractor.QuantizationParams uncertaintiesQuantizationParams;

        public Metadata(ByteBuffer buffer, Model model) throws IOException {
            MetadataExtractor extractor = new MetadataExtractor(buffer);
            inputAudioSamplesShape = extractor.getInputTensorShape(0);
            inputAudioSamplesDataType = DataType.FLOAT32;
            inputAudioSamplesQuantizationParams = extractor.getInputTensorQuantizationParams(0);
            NormalizationOptions inputAudioSamplesNormalizationOptions =
                    (NormalizationOptions) extractor.getInputTensorMetadata(0).processUnits(0).options(new NormalizationOptions());
            FloatBuffer inputAudioSamplesMeanBuffer = inputAudioSamplesNormalizationOptions.meanAsByteBuffer().asFloatBuffer();
            inputAudioSamplesMean = new float[inputAudioSamplesMeanBuffer.limit()];
            inputAudioSamplesMeanBuffer.get(inputAudioSamplesMean);
            FloatBuffer inputAudioSamplesStddevBuffer = inputAudioSamplesNormalizationOptions.stdAsByteBuffer().asFloatBuffer();
            inputAudioSamplesStddev = new float[inputAudioSamplesStddevBuffer.limit()];
            inputAudioSamplesStddevBuffer.get(inputAudioSamplesStddev);
            pitchesShape = model.getOutputTensorShape(0);
            pitchesDataType = DataType.FLOAT32;
            pitchesQuantizationParams = extractor.getOutputTensorQuantizationParams(0);
            uncertaintiesShape = model.getOutputTensorShape(1);
            uncertaintiesDataType = DataType.FLOAT32;
            uncertaintiesQuantizationParams = extractor.getOutputTensorQuantizationParams(1);
        }

        public int[] getInputAudioSamplesShape() {
            return Arrays.copyOf(inputAudioSamplesShape, inputAudioSamplesShape.length);
        }

        public DataType getInputAudioSamplesType() {
            return inputAudioSamplesDataType;
        }

        public MetadataExtractor.QuantizationParams getInputAudioSamplesQuantizationParams() {
            return inputAudioSamplesQuantizationParams;
        }

        public float[] getInputAudioSamplesMean() {
            return Arrays.copyOf(inputAudioSamplesMean, inputAudioSamplesMean.length);
        }

        public float[] getInputAudioSamplesStddev() {
            return Arrays.copyOf(inputAudioSamplesStddev, inputAudioSamplesStddev.length);
        }

        public int[] getPitchesShape() {
            return Arrays.copyOf(pitchesShape, pitchesShape.length);
        }

        public DataType getPitchesType() {
            return pitchesDataType;
        }

        public MetadataExtractor.QuantizationParams getPitchesQuantizationParams() {
            return pitchesQuantizationParams;
        }

        public int[] getUncertaintiesShape() {
            return Arrays.copyOf(uncertaintiesShape, uncertaintiesShape.length);
        }

        public DataType getUncertaintiesType() {
            return uncertaintiesDataType;
        }

        public MetadataExtractor.QuantizationParams getUncertaintiesQuantizationParams() {
            return uncertaintiesQuantizationParams;
        }
    }

    public Metadata getMetadata() {
        return metadata;
    }

    /**
     * Creates interpreter and loads associated files if needed.
     *
     * @throws IOException if an I/O error occurs when loading the tflite model.
     */
    public SpiceTFLiteModel(Context context) throws IOException {
        this(context, MODEL_NAME, Device.CPU, 1);
    }

    /**
     * Creates interpreter and loads associated files if needed, but loading another model in the same
     * input / output structure with the original one.
     *
     * @throws IOException if an I/O error occurs when loading the tflite model.
     */
    public SpiceTFLiteModel(Context context, String modelPath) throws IOException {
        this(context, modelPath, Device.CPU, 1);
    }

    /**
     * Creates interpreter and loads associated files if needed, with device and number of threads
     * configured.
     *
     * @throws IOException if an I/O error occurs when loading the tflite model.
     */
    public SpiceTFLiteModel(Context context, Device device, int numThreads) throws IOException {
        this(context, MODEL_NAME, device, numThreads);
    }

    /**
     * Creates interpreter for a user-specified model.
     *
     * @throws IOException if an I/O error occurs when loading the tflite model.
     */
    public SpiceTFLiteModel(Context context, String modelPath, Device device, int numThreads) throws IOException {
        model = new Model.Builder(context, modelPath).setDevice(device).setNumThreads(numThreads).build();
        metadata = new Metadata(model.getData(), model);

        TensorProcessor.Builder inputAudioSamplesPreprocessorBuilder = new TensorProcessor.Builder()
                .add(new NormalizeOp(metadata.getInputAudioSamplesMean(), metadata.getInputAudioSamplesStddev()))
                .add(new QuantizeOp(
                        metadata.getInputAudioSamplesQuantizationParams().getZeroPoint(),
                        metadata.getInputAudioSamplesQuantizationParams().getScale()))
                .add(new CastOp(DataType.FLOAT32));
        inputAudioSamplesPreprocessor = inputAudioSamplesPreprocessorBuilder.build();

        TensorProcessor.Builder pitchesPostprocessorBuilder = new TensorProcessor.Builder()
                .add(new DequantizeOp(
                        metadata.getPitchesQuantizationParams().getZeroPoint(),
                        metadata.getPitchesQuantizationParams().getScale()));
        pitchesPostprocessor = pitchesPostprocessorBuilder.build();

        TensorProcessor.Builder uncertaintiesPostprocessorBuilder = new TensorProcessor.Builder()
                .add(new DequantizeOp(
                        metadata.getUncertaintiesQuantizationParams().getZeroPoint(),
                        metadata.getUncertaintiesQuantizationParams().getScale()));
        uncertaintiesPostprocessor = uncertaintiesPostprocessorBuilder.build();
    }

    public void resetInputAudioSamplesPreprocessor(@Nullable TensorProcessor processor) {
        inputAudioSamplesPreprocessor = processor;
    }

    public void resetPitchesPostprocessor(@Nullable TensorProcessor processor) {
        pitchesPostprocessor = processor;
    }

    public void resetUncertaintiesPostprocessor(@Nullable TensorProcessor processor) {
        uncertaintiesPostprocessor = processor;
    }

    /** Creates inputs */
    public Inputs createInputs() {
        return new Inputs();
    }

    /** Triggers the model. */
    public Outputs run(Inputs inputs) {
        Outputs outputs = new Outputs();
        model.run(inputs.getBuffer(), outputs.getBuffer());
        return outputs;
    }

    /** Closes the model. */
    public void close() {
        model.close();
    }
}

